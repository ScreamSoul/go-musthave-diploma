// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/screamsoul/go-musthave-diploma/internal/models"
)

// UserLoyaltyRepositoryMock implements repositories.UserLoyaltyRepository
type UserLoyaltyRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckUserPassword          func(ctx context.Context, creds *models.Creds) (u1 uuid.UUID, err error)
	inspectFuncCheckUserPassword   func(ctx context.Context, creds *models.Creds)
	afterCheckUserPasswordCounter  uint64
	beforeCheckUserPasswordCounter uint64
	CheckUserPasswordMock          mUserLoyaltyRepositoryMockCheckUserPassword

	funcCreateOrder          func(ctx context.Context, orderNumber int, userID uuid.UUID) (err error)
	inspectFuncCreateOrder   func(ctx context.Context, orderNumber int, userID uuid.UUID)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mUserLoyaltyRepositoryMockCreateOrder

	funcCreateUser          func(ctx context.Context, creds *models.Creds) (u1 uuid.UUID, err error)
	inspectFuncCreateUser   func(ctx context.Context, creds *models.Creds)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserLoyaltyRepositoryMockCreateUser

	funcGetWallet          func(ctx context.Context, userID uuid.UUID) (up1 *models.UserWallet, err error)
	inspectFuncGetWallet   func(ctx context.Context, userID uuid.UUID)
	afterGetWalletCounter  uint64
	beforeGetWalletCounter uint64
	GetWalletMock          mUserLoyaltyRepositoryMockGetWallet

	funcGetWithdrawals          func(ctx context.Context, userID uuid.UUID) (wa1 []models.Withdraw, err error)
	inspectFuncGetWithdrawals   func(ctx context.Context, userID uuid.UUID)
	afterGetWithdrawalsCounter  uint64
	beforeGetWithdrawalsCounter uint64
	GetWithdrawalsMock          mUserLoyaltyRepositoryMockGetWithdrawals

	funcListOrders          func(ctx context.Context, userID uuid.UUID) (oa1 []models.Order, err error)
	inspectFuncListOrders   func(ctx context.Context, userID uuid.UUID)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mUserLoyaltyRepositoryMockListOrders

	funcPing          func(ctx context.Context) (b1 bool)
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mUserLoyaltyRepositoryMockPing

	funcUpdateOrderAccural          func(ctx context.Context, orderAccural *models.Accural) (err error)
	inspectFuncUpdateOrderAccural   func(ctx context.Context, orderAccural *models.Accural)
	afterUpdateOrderAccuralCounter  uint64
	beforeUpdateOrderAccuralCounter uint64
	UpdateOrderAccuralMock          mUserLoyaltyRepositoryMockUpdateOrderAccural

	funcWithdrawWallet          func(ctx context.Context, userID uuid.UUID, withdraw *models.Withdraw) (err error)
	inspectFuncWithdrawWallet   func(ctx context.Context, userID uuid.UUID, withdraw *models.Withdraw)
	afterWithdrawWalletCounter  uint64
	beforeWithdrawWalletCounter uint64
	WithdrawWalletMock          mUserLoyaltyRepositoryMockWithdrawWallet
}

// NewUserLoyaltyRepositoryMock returns a mock for repositories.UserLoyaltyRepository
func NewUserLoyaltyRepositoryMock(t minimock.Tester) *UserLoyaltyRepositoryMock {
	m := &UserLoyaltyRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckUserPasswordMock = mUserLoyaltyRepositoryMockCheckUserPassword{mock: m}
	m.CheckUserPasswordMock.callArgs = []*UserLoyaltyRepositoryMockCheckUserPasswordParams{}

	m.CreateOrderMock = mUserLoyaltyRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*UserLoyaltyRepositoryMockCreateOrderParams{}

	m.CreateUserMock = mUserLoyaltyRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserLoyaltyRepositoryMockCreateUserParams{}

	m.GetWalletMock = mUserLoyaltyRepositoryMockGetWallet{mock: m}
	m.GetWalletMock.callArgs = []*UserLoyaltyRepositoryMockGetWalletParams{}

	m.GetWithdrawalsMock = mUserLoyaltyRepositoryMockGetWithdrawals{mock: m}
	m.GetWithdrawalsMock.callArgs = []*UserLoyaltyRepositoryMockGetWithdrawalsParams{}

	m.ListOrdersMock = mUserLoyaltyRepositoryMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*UserLoyaltyRepositoryMockListOrdersParams{}

	m.PingMock = mUserLoyaltyRepositoryMockPing{mock: m}
	m.PingMock.callArgs = []*UserLoyaltyRepositoryMockPingParams{}

	m.UpdateOrderAccuralMock = mUserLoyaltyRepositoryMockUpdateOrderAccural{mock: m}
	m.UpdateOrderAccuralMock.callArgs = []*UserLoyaltyRepositoryMockUpdateOrderAccuralParams{}

	m.WithdrawWalletMock = mUserLoyaltyRepositoryMockWithdrawWallet{mock: m}
	m.WithdrawWalletMock.callArgs = []*UserLoyaltyRepositoryMockWithdrawWalletParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserLoyaltyRepositoryMockCheckUserPassword struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockCheckUserPasswordExpectation
	expectations       []*UserLoyaltyRepositoryMockCheckUserPasswordExpectation

	callArgs []*UserLoyaltyRepositoryMockCheckUserPasswordParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockCheckUserPasswordExpectation specifies expectation struct of the UserLoyaltyRepository.CheckUserPassword
type UserLoyaltyRepositoryMockCheckUserPasswordExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockCheckUserPasswordParams
	results *UserLoyaltyRepositoryMockCheckUserPasswordResults
	Counter uint64
}

// UserLoyaltyRepositoryMockCheckUserPasswordParams contains parameters of the UserLoyaltyRepository.CheckUserPassword
type UserLoyaltyRepositoryMockCheckUserPasswordParams struct {
	ctx   context.Context
	creds *models.Creds
}

// UserLoyaltyRepositoryMockCheckUserPasswordResults contains results of the UserLoyaltyRepository.CheckUserPassword
type UserLoyaltyRepositoryMockCheckUserPasswordResults struct {
	u1  uuid.UUID
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.CheckUserPassword
func (mmCheckUserPassword *mUserLoyaltyRepositoryMockCheckUserPassword) Expect(ctx context.Context, creds *models.Creds) *mUserLoyaltyRepositoryMockCheckUserPassword {
	if mmCheckUserPassword.mock.funcCheckUserPassword != nil {
		mmCheckUserPassword.mock.t.Fatalf("UserLoyaltyRepositoryMock.CheckUserPassword mock is already set by Set")
	}

	if mmCheckUserPassword.defaultExpectation == nil {
		mmCheckUserPassword.defaultExpectation = &UserLoyaltyRepositoryMockCheckUserPasswordExpectation{}
	}

	mmCheckUserPassword.defaultExpectation.params = &UserLoyaltyRepositoryMockCheckUserPasswordParams{ctx, creds}
	for _, e := range mmCheckUserPassword.expectations {
		if minimock.Equal(e.params, mmCheckUserPassword.defaultExpectation.params) {
			mmCheckUserPassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckUserPassword.defaultExpectation.params)
		}
	}

	return mmCheckUserPassword
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.CheckUserPassword
func (mmCheckUserPassword *mUserLoyaltyRepositoryMockCheckUserPassword) Inspect(f func(ctx context.Context, creds *models.Creds)) *mUserLoyaltyRepositoryMockCheckUserPassword {
	if mmCheckUserPassword.mock.inspectFuncCheckUserPassword != nil {
		mmCheckUserPassword.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.CheckUserPassword")
	}

	mmCheckUserPassword.mock.inspectFuncCheckUserPassword = f

	return mmCheckUserPassword
}

// Return sets up results that will be returned by UserLoyaltyRepository.CheckUserPassword
func (mmCheckUserPassword *mUserLoyaltyRepositoryMockCheckUserPassword) Return(u1 uuid.UUID, err error) *UserLoyaltyRepositoryMock {
	if mmCheckUserPassword.mock.funcCheckUserPassword != nil {
		mmCheckUserPassword.mock.t.Fatalf("UserLoyaltyRepositoryMock.CheckUserPassword mock is already set by Set")
	}

	if mmCheckUserPassword.defaultExpectation == nil {
		mmCheckUserPassword.defaultExpectation = &UserLoyaltyRepositoryMockCheckUserPasswordExpectation{mock: mmCheckUserPassword.mock}
	}
	mmCheckUserPassword.defaultExpectation.results = &UserLoyaltyRepositoryMockCheckUserPasswordResults{u1, err}
	return mmCheckUserPassword.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.CheckUserPassword method
func (mmCheckUserPassword *mUserLoyaltyRepositoryMockCheckUserPassword) Set(f func(ctx context.Context, creds *models.Creds) (u1 uuid.UUID, err error)) *UserLoyaltyRepositoryMock {
	if mmCheckUserPassword.defaultExpectation != nil {
		mmCheckUserPassword.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.CheckUserPassword method")
	}

	if len(mmCheckUserPassword.expectations) > 0 {
		mmCheckUserPassword.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.CheckUserPassword method")
	}

	mmCheckUserPassword.mock.funcCheckUserPassword = f
	return mmCheckUserPassword.mock
}

// When sets expectation for the UserLoyaltyRepository.CheckUserPassword which will trigger the result defined by the following
// Then helper
func (mmCheckUserPassword *mUserLoyaltyRepositoryMockCheckUserPassword) When(ctx context.Context, creds *models.Creds) *UserLoyaltyRepositoryMockCheckUserPasswordExpectation {
	if mmCheckUserPassword.mock.funcCheckUserPassword != nil {
		mmCheckUserPassword.mock.t.Fatalf("UserLoyaltyRepositoryMock.CheckUserPassword mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockCheckUserPasswordExpectation{
		mock:   mmCheckUserPassword.mock,
		params: &UserLoyaltyRepositoryMockCheckUserPasswordParams{ctx, creds},
	}
	mmCheckUserPassword.expectations = append(mmCheckUserPassword.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.CheckUserPassword return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockCheckUserPasswordExpectation) Then(u1 uuid.UUID, err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockCheckUserPasswordResults{u1, err}
	return e.mock
}

// CheckUserPassword implements repositories.UserLoyaltyRepository
func (mmCheckUserPassword *UserLoyaltyRepositoryMock) CheckUserPassword(ctx context.Context, creds *models.Creds) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCheckUserPassword.beforeCheckUserPasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckUserPassword.afterCheckUserPasswordCounter, 1)

	if mmCheckUserPassword.inspectFuncCheckUserPassword != nil {
		mmCheckUserPassword.inspectFuncCheckUserPassword(ctx, creds)
	}

	mm_params := UserLoyaltyRepositoryMockCheckUserPasswordParams{ctx, creds}

	// Record call args
	mmCheckUserPassword.CheckUserPasswordMock.mutex.Lock()
	mmCheckUserPassword.CheckUserPasswordMock.callArgs = append(mmCheckUserPassword.CheckUserPasswordMock.callArgs, &mm_params)
	mmCheckUserPassword.CheckUserPasswordMock.mutex.Unlock()

	for _, e := range mmCheckUserPassword.CheckUserPasswordMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCheckUserPassword.CheckUserPasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckUserPassword.CheckUserPasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckUserPassword.CheckUserPasswordMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockCheckUserPasswordParams{ctx, creds}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckUserPassword.t.Errorf("UserLoyaltyRepositoryMock.CheckUserPassword got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckUserPassword.CheckUserPasswordMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).u1, (*mm_results).err
		}
		mmCheckUserPassword.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.CheckUserPassword")
	}
	if mmCheckUserPassword.funcCheckUserPassword != nil {
		return mmCheckUserPassword.funcCheckUserPassword(ctx, creds)
	}
	mmCheckUserPassword.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.CheckUserPassword. %v %v", ctx, creds)
	return
}

// CheckUserPasswordAfterCounter returns a count of finished UserLoyaltyRepositoryMock.CheckUserPassword invocations
func (mmCheckUserPassword *UserLoyaltyRepositoryMock) CheckUserPasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckUserPassword.afterCheckUserPasswordCounter)
}

// CheckUserPasswordBeforeCounter returns a count of UserLoyaltyRepositoryMock.CheckUserPassword invocations
func (mmCheckUserPassword *UserLoyaltyRepositoryMock) CheckUserPasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckUserPassword.beforeCheckUserPasswordCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.CheckUserPassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckUserPassword *mUserLoyaltyRepositoryMockCheckUserPassword) Calls() []*UserLoyaltyRepositoryMockCheckUserPasswordParams {
	mmCheckUserPassword.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockCheckUserPasswordParams, len(mmCheckUserPassword.callArgs))
	copy(argCopy, mmCheckUserPassword.callArgs)

	mmCheckUserPassword.mutex.RUnlock()

	return argCopy
}

// MinimockCheckUserPasswordDone returns true if the count of the CheckUserPassword invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockCheckUserPasswordDone() bool {
	for _, e := range m.CheckUserPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckUserPasswordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckUserPasswordCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckUserPassword != nil && mm_atomic.LoadUint64(&m.afterCheckUserPasswordCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckUserPasswordInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockCheckUserPasswordInspect() {
	for _, e := range m.CheckUserPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.CheckUserPassword with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckUserPasswordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckUserPasswordCounter) < 1 {
		if m.CheckUserPasswordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.CheckUserPassword")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.CheckUserPassword with params: %#v", *m.CheckUserPasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckUserPassword != nil && mm_atomic.LoadUint64(&m.afterCheckUserPasswordCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.CheckUserPassword")
	}
}

type mUserLoyaltyRepositoryMockCreateOrder struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockCreateOrderExpectation
	expectations       []*UserLoyaltyRepositoryMockCreateOrderExpectation

	callArgs []*UserLoyaltyRepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockCreateOrderExpectation specifies expectation struct of the UserLoyaltyRepository.CreateOrder
type UserLoyaltyRepositoryMockCreateOrderExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockCreateOrderParams
	results *UserLoyaltyRepositoryMockCreateOrderResults
	Counter uint64
}

// UserLoyaltyRepositoryMockCreateOrderParams contains parameters of the UserLoyaltyRepository.CreateOrder
type UserLoyaltyRepositoryMockCreateOrderParams struct {
	ctx         context.Context
	orderNumber int
	userID      uuid.UUID
}

// UserLoyaltyRepositoryMockCreateOrderResults contains results of the UserLoyaltyRepository.CreateOrder
type UserLoyaltyRepositoryMockCreateOrderResults struct {
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.CreateOrder
func (mmCreateOrder *mUserLoyaltyRepositoryMockCreateOrder) Expect(ctx context.Context, orderNumber int, userID uuid.UUID) *mUserLoyaltyRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("UserLoyaltyRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &UserLoyaltyRepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &UserLoyaltyRepositoryMockCreateOrderParams{ctx, orderNumber, userID}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.CreateOrder
func (mmCreateOrder *mUserLoyaltyRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, orderNumber int, userID uuid.UUID)) *mUserLoyaltyRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by UserLoyaltyRepository.CreateOrder
func (mmCreateOrder *mUserLoyaltyRepositoryMockCreateOrder) Return(err error) *UserLoyaltyRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("UserLoyaltyRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &UserLoyaltyRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &UserLoyaltyRepositoryMockCreateOrderResults{err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.CreateOrder method
func (mmCreateOrder *mUserLoyaltyRepositoryMockCreateOrder) Set(f func(ctx context.Context, orderNumber int, userID uuid.UUID) (err error)) *UserLoyaltyRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the UserLoyaltyRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mUserLoyaltyRepositoryMockCreateOrder) When(ctx context.Context, orderNumber int, userID uuid.UUID) *UserLoyaltyRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("UserLoyaltyRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &UserLoyaltyRepositoryMockCreateOrderParams{ctx, orderNumber, userID},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockCreateOrderExpectation) Then(err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockCreateOrderResults{err}
	return e.mock
}

// CreateOrder implements repositories.UserLoyaltyRepository
func (mmCreateOrder *UserLoyaltyRepositoryMock) CreateOrder(ctx context.Context, orderNumber int, userID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, orderNumber, userID)
	}

	mm_params := UserLoyaltyRepositoryMockCreateOrderParams{ctx, orderNumber, userID}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockCreateOrderParams{ctx, orderNumber, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("UserLoyaltyRepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).err
		}
		mmCreateOrder.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.CreateOrder")
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, orderNumber, userID)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.CreateOrder. %v %v %v", ctx, orderNumber, userID)
	return
}

// CreateOrderAfterCounter returns a count of finished UserLoyaltyRepositoryMock.CreateOrder invocations
func (mmCreateOrder *UserLoyaltyRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of UserLoyaltyRepositoryMock.CreateOrder invocations
func (mmCreateOrder *UserLoyaltyRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mUserLoyaltyRepositoryMockCreateOrder) Calls() []*UserLoyaltyRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.CreateOrder")
	}
}

type mUserLoyaltyRepositoryMockCreateUser struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockCreateUserExpectation
	expectations       []*UserLoyaltyRepositoryMockCreateUserExpectation

	callArgs []*UserLoyaltyRepositoryMockCreateUserParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockCreateUserExpectation specifies expectation struct of the UserLoyaltyRepository.CreateUser
type UserLoyaltyRepositoryMockCreateUserExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockCreateUserParams
	results *UserLoyaltyRepositoryMockCreateUserResults
	Counter uint64
}

// UserLoyaltyRepositoryMockCreateUserParams contains parameters of the UserLoyaltyRepository.CreateUser
type UserLoyaltyRepositoryMockCreateUserParams struct {
	ctx   context.Context
	creds *models.Creds
}

// UserLoyaltyRepositoryMockCreateUserResults contains results of the UserLoyaltyRepository.CreateUser
type UserLoyaltyRepositoryMockCreateUserResults struct {
	u1  uuid.UUID
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.CreateUser
func (mmCreateUser *mUserLoyaltyRepositoryMockCreateUser) Expect(ctx context.Context, creds *models.Creds) *mUserLoyaltyRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserLoyaltyRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserLoyaltyRepositoryMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &UserLoyaltyRepositoryMockCreateUserParams{ctx, creds}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.CreateUser
func (mmCreateUser *mUserLoyaltyRepositoryMockCreateUser) Inspect(f func(ctx context.Context, creds *models.Creds)) *mUserLoyaltyRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserLoyaltyRepository.CreateUser
func (mmCreateUser *mUserLoyaltyRepositoryMockCreateUser) Return(u1 uuid.UUID, err error) *UserLoyaltyRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserLoyaltyRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserLoyaltyRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserLoyaltyRepositoryMockCreateUserResults{u1, err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.CreateUser method
func (mmCreateUser *mUserLoyaltyRepositoryMockCreateUser) Set(f func(ctx context.Context, creds *models.Creds) (u1 uuid.UUID, err error)) *UserLoyaltyRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the UserLoyaltyRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserLoyaltyRepositoryMockCreateUser) When(ctx context.Context, creds *models.Creds) *UserLoyaltyRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserLoyaltyRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &UserLoyaltyRepositoryMockCreateUserParams{ctx, creds},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockCreateUserExpectation) Then(u1 uuid.UUID, err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockCreateUserResults{u1, err}
	return e.mock
}

// CreateUser implements repositories.UserLoyaltyRepository
func (mmCreateUser *UserLoyaltyRepositoryMock) CreateUser(ctx context.Context, creds *models.Creds) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, creds)
	}

	mm_params := UserLoyaltyRepositoryMockCreateUserParams{ctx, creds}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockCreateUserParams{ctx, creds}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserLoyaltyRepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).u1, (*mm_results).err
		}
		mmCreateUser.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.CreateUser")
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, creds)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.CreateUser. %v %v", ctx, creds)
	return
}

// CreateUserAfterCounter returns a count of finished UserLoyaltyRepositoryMock.CreateUser invocations
func (mmCreateUser *UserLoyaltyRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserLoyaltyRepositoryMock.CreateUser invocations
func (mmCreateUser *UserLoyaltyRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserLoyaltyRepositoryMockCreateUser) Calls() []*UserLoyaltyRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.CreateUser")
	}
}

type mUserLoyaltyRepositoryMockGetWallet struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockGetWalletExpectation
	expectations       []*UserLoyaltyRepositoryMockGetWalletExpectation

	callArgs []*UserLoyaltyRepositoryMockGetWalletParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockGetWalletExpectation specifies expectation struct of the UserLoyaltyRepository.GetWallet
type UserLoyaltyRepositoryMockGetWalletExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockGetWalletParams
	results *UserLoyaltyRepositoryMockGetWalletResults
	Counter uint64
}

// UserLoyaltyRepositoryMockGetWalletParams contains parameters of the UserLoyaltyRepository.GetWallet
type UserLoyaltyRepositoryMockGetWalletParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// UserLoyaltyRepositoryMockGetWalletResults contains results of the UserLoyaltyRepository.GetWallet
type UserLoyaltyRepositoryMockGetWalletResults struct {
	up1 *models.UserWallet
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.GetWallet
func (mmGetWallet *mUserLoyaltyRepositoryMockGetWallet) Expect(ctx context.Context, userID uuid.UUID) *mUserLoyaltyRepositoryMockGetWallet {
	if mmGetWallet.mock.funcGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("UserLoyaltyRepositoryMock.GetWallet mock is already set by Set")
	}

	if mmGetWallet.defaultExpectation == nil {
		mmGetWallet.defaultExpectation = &UserLoyaltyRepositoryMockGetWalletExpectation{}
	}

	mmGetWallet.defaultExpectation.params = &UserLoyaltyRepositoryMockGetWalletParams{ctx, userID}
	for _, e := range mmGetWallet.expectations {
		if minimock.Equal(e.params, mmGetWallet.defaultExpectation.params) {
			mmGetWallet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWallet.defaultExpectation.params)
		}
	}

	return mmGetWallet
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.GetWallet
func (mmGetWallet *mUserLoyaltyRepositoryMockGetWallet) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mUserLoyaltyRepositoryMockGetWallet {
	if mmGetWallet.mock.inspectFuncGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.GetWallet")
	}

	mmGetWallet.mock.inspectFuncGetWallet = f

	return mmGetWallet
}

// Return sets up results that will be returned by UserLoyaltyRepository.GetWallet
func (mmGetWallet *mUserLoyaltyRepositoryMockGetWallet) Return(up1 *models.UserWallet, err error) *UserLoyaltyRepositoryMock {
	if mmGetWallet.mock.funcGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("UserLoyaltyRepositoryMock.GetWallet mock is already set by Set")
	}

	if mmGetWallet.defaultExpectation == nil {
		mmGetWallet.defaultExpectation = &UserLoyaltyRepositoryMockGetWalletExpectation{mock: mmGetWallet.mock}
	}
	mmGetWallet.defaultExpectation.results = &UserLoyaltyRepositoryMockGetWalletResults{up1, err}
	return mmGetWallet.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.GetWallet method
func (mmGetWallet *mUserLoyaltyRepositoryMockGetWallet) Set(f func(ctx context.Context, userID uuid.UUID) (up1 *models.UserWallet, err error)) *UserLoyaltyRepositoryMock {
	if mmGetWallet.defaultExpectation != nil {
		mmGetWallet.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.GetWallet method")
	}

	if len(mmGetWallet.expectations) > 0 {
		mmGetWallet.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.GetWallet method")
	}

	mmGetWallet.mock.funcGetWallet = f
	return mmGetWallet.mock
}

// When sets expectation for the UserLoyaltyRepository.GetWallet which will trigger the result defined by the following
// Then helper
func (mmGetWallet *mUserLoyaltyRepositoryMockGetWallet) When(ctx context.Context, userID uuid.UUID) *UserLoyaltyRepositoryMockGetWalletExpectation {
	if mmGetWallet.mock.funcGetWallet != nil {
		mmGetWallet.mock.t.Fatalf("UserLoyaltyRepositoryMock.GetWallet mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockGetWalletExpectation{
		mock:   mmGetWallet.mock,
		params: &UserLoyaltyRepositoryMockGetWalletParams{ctx, userID},
	}
	mmGetWallet.expectations = append(mmGetWallet.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.GetWallet return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockGetWalletExpectation) Then(up1 *models.UserWallet, err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockGetWalletResults{up1, err}
	return e.mock
}

// GetWallet implements repositories.UserLoyaltyRepository
func (mmGetWallet *UserLoyaltyRepositoryMock) GetWallet(ctx context.Context, userID uuid.UUID) (up1 *models.UserWallet, err error) {
	mm_atomic.AddUint64(&mmGetWallet.beforeGetWalletCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWallet.afterGetWalletCounter, 1)

	if mmGetWallet.inspectFuncGetWallet != nil {
		mmGetWallet.inspectFuncGetWallet(ctx, userID)
	}

	mm_params := UserLoyaltyRepositoryMockGetWalletParams{ctx, userID}

	// Record call args
	mmGetWallet.GetWalletMock.mutex.Lock()
	mmGetWallet.GetWalletMock.callArgs = append(mmGetWallet.GetWalletMock.callArgs, &mm_params)
	mmGetWallet.GetWalletMock.mutex.Unlock()

	for _, e := range mmGetWallet.GetWalletMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetWallet.GetWalletMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWallet.GetWalletMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWallet.GetWalletMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockGetWalletParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWallet.t.Errorf("UserLoyaltyRepositoryMock.GetWallet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWallet.GetWalletMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).up1, (*mm_results).err
		}
		mmGetWallet.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.GetWallet")
	}
	if mmGetWallet.funcGetWallet != nil {
		return mmGetWallet.funcGetWallet(ctx, userID)
	}
	mmGetWallet.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.GetWallet. %v %v", ctx, userID)
	return
}

// GetWalletAfterCounter returns a count of finished UserLoyaltyRepositoryMock.GetWallet invocations
func (mmGetWallet *UserLoyaltyRepositoryMock) GetWalletAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWallet.afterGetWalletCounter)
}

// GetWalletBeforeCounter returns a count of UserLoyaltyRepositoryMock.GetWallet invocations
func (mmGetWallet *UserLoyaltyRepositoryMock) GetWalletBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWallet.beforeGetWalletCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.GetWallet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWallet *mUserLoyaltyRepositoryMockGetWallet) Calls() []*UserLoyaltyRepositoryMockGetWalletParams {
	mmGetWallet.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockGetWalletParams, len(mmGetWallet.callArgs))
	copy(argCopy, mmGetWallet.callArgs)

	mmGetWallet.mutex.RUnlock()

	return argCopy
}

// MinimockGetWalletDone returns true if the count of the GetWallet invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockGetWalletDone() bool {
	for _, e := range m.GetWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWallet != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWalletInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockGetWalletInspect() {
	for _, e := range m.GetWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.GetWallet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		if m.GetWalletMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.GetWallet")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.GetWallet with params: %#v", *m.GetWalletMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWallet != nil && mm_atomic.LoadUint64(&m.afterGetWalletCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.GetWallet")
	}
}

type mUserLoyaltyRepositoryMockGetWithdrawals struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockGetWithdrawalsExpectation
	expectations       []*UserLoyaltyRepositoryMockGetWithdrawalsExpectation

	callArgs []*UserLoyaltyRepositoryMockGetWithdrawalsParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockGetWithdrawalsExpectation specifies expectation struct of the UserLoyaltyRepository.GetWithdrawals
type UserLoyaltyRepositoryMockGetWithdrawalsExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockGetWithdrawalsParams
	results *UserLoyaltyRepositoryMockGetWithdrawalsResults
	Counter uint64
}

// UserLoyaltyRepositoryMockGetWithdrawalsParams contains parameters of the UserLoyaltyRepository.GetWithdrawals
type UserLoyaltyRepositoryMockGetWithdrawalsParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// UserLoyaltyRepositoryMockGetWithdrawalsResults contains results of the UserLoyaltyRepository.GetWithdrawals
type UserLoyaltyRepositoryMockGetWithdrawalsResults struct {
	wa1 []models.Withdraw
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.GetWithdrawals
func (mmGetWithdrawals *mUserLoyaltyRepositoryMockGetWithdrawals) Expect(ctx context.Context, userID uuid.UUID) *mUserLoyaltyRepositoryMockGetWithdrawals {
	if mmGetWithdrawals.mock.funcGetWithdrawals != nil {
		mmGetWithdrawals.mock.t.Fatalf("UserLoyaltyRepositoryMock.GetWithdrawals mock is already set by Set")
	}

	if mmGetWithdrawals.defaultExpectation == nil {
		mmGetWithdrawals.defaultExpectation = &UserLoyaltyRepositoryMockGetWithdrawalsExpectation{}
	}

	mmGetWithdrawals.defaultExpectation.params = &UserLoyaltyRepositoryMockGetWithdrawalsParams{ctx, userID}
	for _, e := range mmGetWithdrawals.expectations {
		if minimock.Equal(e.params, mmGetWithdrawals.defaultExpectation.params) {
			mmGetWithdrawals.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWithdrawals.defaultExpectation.params)
		}
	}

	return mmGetWithdrawals
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.GetWithdrawals
func (mmGetWithdrawals *mUserLoyaltyRepositoryMockGetWithdrawals) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mUserLoyaltyRepositoryMockGetWithdrawals {
	if mmGetWithdrawals.mock.inspectFuncGetWithdrawals != nil {
		mmGetWithdrawals.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.GetWithdrawals")
	}

	mmGetWithdrawals.mock.inspectFuncGetWithdrawals = f

	return mmGetWithdrawals
}

// Return sets up results that will be returned by UserLoyaltyRepository.GetWithdrawals
func (mmGetWithdrawals *mUserLoyaltyRepositoryMockGetWithdrawals) Return(wa1 []models.Withdraw, err error) *UserLoyaltyRepositoryMock {
	if mmGetWithdrawals.mock.funcGetWithdrawals != nil {
		mmGetWithdrawals.mock.t.Fatalf("UserLoyaltyRepositoryMock.GetWithdrawals mock is already set by Set")
	}

	if mmGetWithdrawals.defaultExpectation == nil {
		mmGetWithdrawals.defaultExpectation = &UserLoyaltyRepositoryMockGetWithdrawalsExpectation{mock: mmGetWithdrawals.mock}
	}
	mmGetWithdrawals.defaultExpectation.results = &UserLoyaltyRepositoryMockGetWithdrawalsResults{wa1, err}
	return mmGetWithdrawals.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.GetWithdrawals method
func (mmGetWithdrawals *mUserLoyaltyRepositoryMockGetWithdrawals) Set(f func(ctx context.Context, userID uuid.UUID) (wa1 []models.Withdraw, err error)) *UserLoyaltyRepositoryMock {
	if mmGetWithdrawals.defaultExpectation != nil {
		mmGetWithdrawals.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.GetWithdrawals method")
	}

	if len(mmGetWithdrawals.expectations) > 0 {
		mmGetWithdrawals.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.GetWithdrawals method")
	}

	mmGetWithdrawals.mock.funcGetWithdrawals = f
	return mmGetWithdrawals.mock
}

// When sets expectation for the UserLoyaltyRepository.GetWithdrawals which will trigger the result defined by the following
// Then helper
func (mmGetWithdrawals *mUserLoyaltyRepositoryMockGetWithdrawals) When(ctx context.Context, userID uuid.UUID) *UserLoyaltyRepositoryMockGetWithdrawalsExpectation {
	if mmGetWithdrawals.mock.funcGetWithdrawals != nil {
		mmGetWithdrawals.mock.t.Fatalf("UserLoyaltyRepositoryMock.GetWithdrawals mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockGetWithdrawalsExpectation{
		mock:   mmGetWithdrawals.mock,
		params: &UserLoyaltyRepositoryMockGetWithdrawalsParams{ctx, userID},
	}
	mmGetWithdrawals.expectations = append(mmGetWithdrawals.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.GetWithdrawals return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockGetWithdrawalsExpectation) Then(wa1 []models.Withdraw, err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockGetWithdrawalsResults{wa1, err}
	return e.mock
}

// GetWithdrawals implements repositories.UserLoyaltyRepository
func (mmGetWithdrawals *UserLoyaltyRepositoryMock) GetWithdrawals(ctx context.Context, userID uuid.UUID) (wa1 []models.Withdraw, err error) {
	mm_atomic.AddUint64(&mmGetWithdrawals.beforeGetWithdrawalsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWithdrawals.afterGetWithdrawalsCounter, 1)

	if mmGetWithdrawals.inspectFuncGetWithdrawals != nil {
		mmGetWithdrawals.inspectFuncGetWithdrawals(ctx, userID)
	}

	mm_params := UserLoyaltyRepositoryMockGetWithdrawalsParams{ctx, userID}

	// Record call args
	mmGetWithdrawals.GetWithdrawalsMock.mutex.Lock()
	mmGetWithdrawals.GetWithdrawalsMock.callArgs = append(mmGetWithdrawals.GetWithdrawalsMock.callArgs, &mm_params)
	mmGetWithdrawals.GetWithdrawalsMock.mutex.Unlock()

	for _, e := range mmGetWithdrawals.GetWithdrawalsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wa1, e.results.err
		}
	}

	if mmGetWithdrawals.GetWithdrawalsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWithdrawals.GetWithdrawalsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWithdrawals.GetWithdrawalsMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockGetWithdrawalsParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWithdrawals.t.Errorf("UserLoyaltyRepositoryMock.GetWithdrawals got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWithdrawals.GetWithdrawalsMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).wa1, (*mm_results).err
		}
		mmGetWithdrawals.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.GetWithdrawals")
	}
	if mmGetWithdrawals.funcGetWithdrawals != nil {
		return mmGetWithdrawals.funcGetWithdrawals(ctx, userID)
	}
	mmGetWithdrawals.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.GetWithdrawals. %v %v", ctx, userID)
	return
}

// GetWithdrawalsAfterCounter returns a count of finished UserLoyaltyRepositoryMock.GetWithdrawals invocations
func (mmGetWithdrawals *UserLoyaltyRepositoryMock) GetWithdrawalsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWithdrawals.afterGetWithdrawalsCounter)
}

// GetWithdrawalsBeforeCounter returns a count of UserLoyaltyRepositoryMock.GetWithdrawals invocations
func (mmGetWithdrawals *UserLoyaltyRepositoryMock) GetWithdrawalsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWithdrawals.beforeGetWithdrawalsCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.GetWithdrawals.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWithdrawals *mUserLoyaltyRepositoryMockGetWithdrawals) Calls() []*UserLoyaltyRepositoryMockGetWithdrawalsParams {
	mmGetWithdrawals.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockGetWithdrawalsParams, len(mmGetWithdrawals.callArgs))
	copy(argCopy, mmGetWithdrawals.callArgs)

	mmGetWithdrawals.mutex.RUnlock()

	return argCopy
}

// MinimockGetWithdrawalsDone returns true if the count of the GetWithdrawals invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockGetWithdrawalsDone() bool {
	for _, e := range m.GetWithdrawalsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWithdrawalsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWithdrawalsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWithdrawals != nil && mm_atomic.LoadUint64(&m.afterGetWithdrawalsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWithdrawalsInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockGetWithdrawalsInspect() {
	for _, e := range m.GetWithdrawalsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.GetWithdrawals with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWithdrawalsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWithdrawalsCounter) < 1 {
		if m.GetWithdrawalsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.GetWithdrawals")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.GetWithdrawals with params: %#v", *m.GetWithdrawalsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWithdrawals != nil && mm_atomic.LoadUint64(&m.afterGetWithdrawalsCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.GetWithdrawals")
	}
}

type mUserLoyaltyRepositoryMockListOrders struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockListOrdersExpectation
	expectations       []*UserLoyaltyRepositoryMockListOrdersExpectation

	callArgs []*UserLoyaltyRepositoryMockListOrdersParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockListOrdersExpectation specifies expectation struct of the UserLoyaltyRepository.ListOrders
type UserLoyaltyRepositoryMockListOrdersExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockListOrdersParams
	results *UserLoyaltyRepositoryMockListOrdersResults
	Counter uint64
}

// UserLoyaltyRepositoryMockListOrdersParams contains parameters of the UserLoyaltyRepository.ListOrders
type UserLoyaltyRepositoryMockListOrdersParams struct {
	ctx    context.Context
	userID uuid.UUID
}

// UserLoyaltyRepositoryMockListOrdersResults contains results of the UserLoyaltyRepository.ListOrders
type UserLoyaltyRepositoryMockListOrdersResults struct {
	oa1 []models.Order
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.ListOrders
func (mmListOrders *mUserLoyaltyRepositoryMockListOrders) Expect(ctx context.Context, userID uuid.UUID) *mUserLoyaltyRepositoryMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("UserLoyaltyRepositoryMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &UserLoyaltyRepositoryMockListOrdersExpectation{}
	}

	mmListOrders.defaultExpectation.params = &UserLoyaltyRepositoryMockListOrdersParams{ctx, userID}
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.ListOrders
func (mmListOrders *mUserLoyaltyRepositoryMockListOrders) Inspect(f func(ctx context.Context, userID uuid.UUID)) *mUserLoyaltyRepositoryMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by UserLoyaltyRepository.ListOrders
func (mmListOrders *mUserLoyaltyRepositoryMockListOrders) Return(oa1 []models.Order, err error) *UserLoyaltyRepositoryMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("UserLoyaltyRepositoryMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &UserLoyaltyRepositoryMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &UserLoyaltyRepositoryMockListOrdersResults{oa1, err}
	return mmListOrders.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.ListOrders method
func (mmListOrders *mUserLoyaltyRepositoryMockListOrders) Set(f func(ctx context.Context, userID uuid.UUID) (oa1 []models.Order, err error)) *UserLoyaltyRepositoryMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	return mmListOrders.mock
}

// When sets expectation for the UserLoyaltyRepository.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mUserLoyaltyRepositoryMockListOrders) When(ctx context.Context, userID uuid.UUID) *UserLoyaltyRepositoryMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("UserLoyaltyRepositoryMock.ListOrders mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockListOrdersExpectation{
		mock:   mmListOrders.mock,
		params: &UserLoyaltyRepositoryMockListOrdersParams{ctx, userID},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.ListOrders return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockListOrdersExpectation) Then(oa1 []models.Order, err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockListOrdersResults{oa1, err}
	return e.mock
}

// ListOrders implements repositories.UserLoyaltyRepository
func (mmListOrders *UserLoyaltyRepositoryMock) ListOrders(ctx context.Context, userID uuid.UUID) (oa1 []models.Order, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx, userID)
	}

	mm_params := UserLoyaltyRepositoryMockListOrdersParams{ctx, userID}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockListOrdersParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("UserLoyaltyRepositoryMock.ListOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).oa1, (*mm_results).err
		}
		mmListOrders.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.ListOrders")
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx, userID)
	}
	mmListOrders.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.ListOrders. %v %v", ctx, userID)
	return
}

// ListOrdersAfterCounter returns a count of finished UserLoyaltyRepositoryMock.ListOrders invocations
func (mmListOrders *UserLoyaltyRepositoryMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of UserLoyaltyRepositoryMock.ListOrders invocations
func (mmListOrders *UserLoyaltyRepositoryMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mUserLoyaltyRepositoryMockListOrders) Calls() []*UserLoyaltyRepositoryMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockListOrdersDone() bool {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.ListOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.ListOrders")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.ListOrders with params: %#v", *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.ListOrders")
	}
}

type mUserLoyaltyRepositoryMockPing struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockPingExpectation
	expectations       []*UserLoyaltyRepositoryMockPingExpectation

	callArgs []*UserLoyaltyRepositoryMockPingParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockPingExpectation specifies expectation struct of the UserLoyaltyRepository.Ping
type UserLoyaltyRepositoryMockPingExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockPingParams
	results *UserLoyaltyRepositoryMockPingResults
	Counter uint64
}

// UserLoyaltyRepositoryMockPingParams contains parameters of the UserLoyaltyRepository.Ping
type UserLoyaltyRepositoryMockPingParams struct {
	ctx context.Context
}

// UserLoyaltyRepositoryMockPingResults contains results of the UserLoyaltyRepository.Ping
type UserLoyaltyRepositoryMockPingResults struct {
	b1 bool
}

// Expect sets up expected params for UserLoyaltyRepository.Ping
func (mmPing *mUserLoyaltyRepositoryMockPing) Expect(ctx context.Context) *mUserLoyaltyRepositoryMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("UserLoyaltyRepositoryMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &UserLoyaltyRepositoryMockPingExpectation{}
	}

	mmPing.defaultExpectation.params = &UserLoyaltyRepositoryMockPingParams{ctx}
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.Ping
func (mmPing *mUserLoyaltyRepositoryMockPing) Inspect(f func(ctx context.Context)) *mUserLoyaltyRepositoryMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by UserLoyaltyRepository.Ping
func (mmPing *mUserLoyaltyRepositoryMockPing) Return(b1 bool) *UserLoyaltyRepositoryMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("UserLoyaltyRepositoryMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &UserLoyaltyRepositoryMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &UserLoyaltyRepositoryMockPingResults{b1}
	return mmPing.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.Ping method
func (mmPing *mUserLoyaltyRepositoryMockPing) Set(f func(ctx context.Context) (b1 bool)) *UserLoyaltyRepositoryMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.Ping method")
	}

	mmPing.mock.funcPing = f
	return mmPing.mock
}

// When sets expectation for the UserLoyaltyRepository.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mUserLoyaltyRepositoryMockPing) When(ctx context.Context) *UserLoyaltyRepositoryMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("UserLoyaltyRepositoryMock.Ping mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockPingExpectation{
		mock:   mmPing.mock,
		params: &UserLoyaltyRepositoryMockPingParams{ctx},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.Ping return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockPingExpectation) Then(b1 bool) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockPingResults{b1}
	return e.mock
}

// Ping implements repositories.UserLoyaltyRepository
func (mmPing *UserLoyaltyRepositoryMock) Ping(ctx context.Context) (b1 bool) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := UserLoyaltyRepositoryMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockPingParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("UserLoyaltyRepositoryMock.Ping got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).b1
		}
		mmPing.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.Ping")
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished UserLoyaltyRepositoryMock.Ping invocations
func (mmPing *UserLoyaltyRepositoryMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of UserLoyaltyRepositoryMock.Ping invocations
func (mmPing *UserLoyaltyRepositoryMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mUserLoyaltyRepositoryMockPing) Calls() []*UserLoyaltyRepositoryMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockPingDone() bool {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPingInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.Ping with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.Ping")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.Ping with params: %#v", *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.Ping")
	}
}

type mUserLoyaltyRepositoryMockUpdateOrderAccural struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation
	expectations       []*UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation

	callArgs []*UserLoyaltyRepositoryMockUpdateOrderAccuralParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation specifies expectation struct of the UserLoyaltyRepository.UpdateOrderAccural
type UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockUpdateOrderAccuralParams
	results *UserLoyaltyRepositoryMockUpdateOrderAccuralResults
	Counter uint64
}

// UserLoyaltyRepositoryMockUpdateOrderAccuralParams contains parameters of the UserLoyaltyRepository.UpdateOrderAccural
type UserLoyaltyRepositoryMockUpdateOrderAccuralParams struct {
	ctx          context.Context
	orderAccural *models.Accural
}

// UserLoyaltyRepositoryMockUpdateOrderAccuralResults contains results of the UserLoyaltyRepository.UpdateOrderAccural
type UserLoyaltyRepositoryMockUpdateOrderAccuralResults struct {
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.UpdateOrderAccural
func (mmUpdateOrderAccural *mUserLoyaltyRepositoryMockUpdateOrderAccural) Expect(ctx context.Context, orderAccural *models.Accural) *mUserLoyaltyRepositoryMockUpdateOrderAccural {
	if mmUpdateOrderAccural.mock.funcUpdateOrderAccural != nil {
		mmUpdateOrderAccural.mock.t.Fatalf("UserLoyaltyRepositoryMock.UpdateOrderAccural mock is already set by Set")
	}

	if mmUpdateOrderAccural.defaultExpectation == nil {
		mmUpdateOrderAccural.defaultExpectation = &UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation{}
	}

	mmUpdateOrderAccural.defaultExpectation.params = &UserLoyaltyRepositoryMockUpdateOrderAccuralParams{ctx, orderAccural}
	for _, e := range mmUpdateOrderAccural.expectations {
		if minimock.Equal(e.params, mmUpdateOrderAccural.defaultExpectation.params) {
			mmUpdateOrderAccural.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderAccural.defaultExpectation.params)
		}
	}

	return mmUpdateOrderAccural
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.UpdateOrderAccural
func (mmUpdateOrderAccural *mUserLoyaltyRepositoryMockUpdateOrderAccural) Inspect(f func(ctx context.Context, orderAccural *models.Accural)) *mUserLoyaltyRepositoryMockUpdateOrderAccural {
	if mmUpdateOrderAccural.mock.inspectFuncUpdateOrderAccural != nil {
		mmUpdateOrderAccural.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.UpdateOrderAccural")
	}

	mmUpdateOrderAccural.mock.inspectFuncUpdateOrderAccural = f

	return mmUpdateOrderAccural
}

// Return sets up results that will be returned by UserLoyaltyRepository.UpdateOrderAccural
func (mmUpdateOrderAccural *mUserLoyaltyRepositoryMockUpdateOrderAccural) Return(err error) *UserLoyaltyRepositoryMock {
	if mmUpdateOrderAccural.mock.funcUpdateOrderAccural != nil {
		mmUpdateOrderAccural.mock.t.Fatalf("UserLoyaltyRepositoryMock.UpdateOrderAccural mock is already set by Set")
	}

	if mmUpdateOrderAccural.defaultExpectation == nil {
		mmUpdateOrderAccural.defaultExpectation = &UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation{mock: mmUpdateOrderAccural.mock}
	}
	mmUpdateOrderAccural.defaultExpectation.results = &UserLoyaltyRepositoryMockUpdateOrderAccuralResults{err}
	return mmUpdateOrderAccural.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.UpdateOrderAccural method
func (mmUpdateOrderAccural *mUserLoyaltyRepositoryMockUpdateOrderAccural) Set(f func(ctx context.Context, orderAccural *models.Accural) (err error)) *UserLoyaltyRepositoryMock {
	if mmUpdateOrderAccural.defaultExpectation != nil {
		mmUpdateOrderAccural.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.UpdateOrderAccural method")
	}

	if len(mmUpdateOrderAccural.expectations) > 0 {
		mmUpdateOrderAccural.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.UpdateOrderAccural method")
	}

	mmUpdateOrderAccural.mock.funcUpdateOrderAccural = f
	return mmUpdateOrderAccural.mock
}

// When sets expectation for the UserLoyaltyRepository.UpdateOrderAccural which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderAccural *mUserLoyaltyRepositoryMockUpdateOrderAccural) When(ctx context.Context, orderAccural *models.Accural) *UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation {
	if mmUpdateOrderAccural.mock.funcUpdateOrderAccural != nil {
		mmUpdateOrderAccural.mock.t.Fatalf("UserLoyaltyRepositoryMock.UpdateOrderAccural mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation{
		mock:   mmUpdateOrderAccural.mock,
		params: &UserLoyaltyRepositoryMockUpdateOrderAccuralParams{ctx, orderAccural},
	}
	mmUpdateOrderAccural.expectations = append(mmUpdateOrderAccural.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.UpdateOrderAccural return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockUpdateOrderAccuralExpectation) Then(err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockUpdateOrderAccuralResults{err}
	return e.mock
}

// UpdateOrderAccural implements repositories.UserLoyaltyRepository
func (mmUpdateOrderAccural *UserLoyaltyRepositoryMock) UpdateOrderAccural(ctx context.Context, orderAccural *models.Accural) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderAccural.beforeUpdateOrderAccuralCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderAccural.afterUpdateOrderAccuralCounter, 1)

	if mmUpdateOrderAccural.inspectFuncUpdateOrderAccural != nil {
		mmUpdateOrderAccural.inspectFuncUpdateOrderAccural(ctx, orderAccural)
	}

	mm_params := UserLoyaltyRepositoryMockUpdateOrderAccuralParams{ctx, orderAccural}

	// Record call args
	mmUpdateOrderAccural.UpdateOrderAccuralMock.mutex.Lock()
	mmUpdateOrderAccural.UpdateOrderAccuralMock.callArgs = append(mmUpdateOrderAccural.UpdateOrderAccuralMock.callArgs, &mm_params)
	mmUpdateOrderAccural.UpdateOrderAccuralMock.mutex.Unlock()

	for _, e := range mmUpdateOrderAccural.UpdateOrderAccuralMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderAccural.UpdateOrderAccuralMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderAccural.UpdateOrderAccuralMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderAccural.UpdateOrderAccuralMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockUpdateOrderAccuralParams{ctx, orderAccural}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderAccural.t.Errorf("UserLoyaltyRepositoryMock.UpdateOrderAccural got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderAccural.UpdateOrderAccuralMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).err
		}
		mmUpdateOrderAccural.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.UpdateOrderAccural")
	}
	if mmUpdateOrderAccural.funcUpdateOrderAccural != nil {
		return mmUpdateOrderAccural.funcUpdateOrderAccural(ctx, orderAccural)
	}
	mmUpdateOrderAccural.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.UpdateOrderAccural. %v %v", ctx, orderAccural)
	return
}

// UpdateOrderAccuralAfterCounter returns a count of finished UserLoyaltyRepositoryMock.UpdateOrderAccural invocations
func (mmUpdateOrderAccural *UserLoyaltyRepositoryMock) UpdateOrderAccuralAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderAccural.afterUpdateOrderAccuralCounter)
}

// UpdateOrderAccuralBeforeCounter returns a count of UserLoyaltyRepositoryMock.UpdateOrderAccural invocations
func (mmUpdateOrderAccural *UserLoyaltyRepositoryMock) UpdateOrderAccuralBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderAccural.beforeUpdateOrderAccuralCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.UpdateOrderAccural.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderAccural *mUserLoyaltyRepositoryMockUpdateOrderAccural) Calls() []*UserLoyaltyRepositoryMockUpdateOrderAccuralParams {
	mmUpdateOrderAccural.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockUpdateOrderAccuralParams, len(mmUpdateOrderAccural.callArgs))
	copy(argCopy, mmUpdateOrderAccural.callArgs)

	mmUpdateOrderAccural.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderAccuralDone returns true if the count of the UpdateOrderAccural invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockUpdateOrderAccuralDone() bool {
	for _, e := range m.UpdateOrderAccuralMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderAccuralMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderAccuralCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderAccural != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderAccuralCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderAccuralInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockUpdateOrderAccuralInspect() {
	for _, e := range m.UpdateOrderAccuralMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.UpdateOrderAccural with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderAccuralMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderAccuralCounter) < 1 {
		if m.UpdateOrderAccuralMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.UpdateOrderAccural")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.UpdateOrderAccural with params: %#v", *m.UpdateOrderAccuralMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderAccural != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderAccuralCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.UpdateOrderAccural")
	}
}

type mUserLoyaltyRepositoryMockWithdrawWallet struct {
	mock               *UserLoyaltyRepositoryMock
	defaultExpectation *UserLoyaltyRepositoryMockWithdrawWalletExpectation
	expectations       []*UserLoyaltyRepositoryMockWithdrawWalletExpectation

	callArgs []*UserLoyaltyRepositoryMockWithdrawWalletParams
	mutex    sync.RWMutex
}

// UserLoyaltyRepositoryMockWithdrawWalletExpectation specifies expectation struct of the UserLoyaltyRepository.WithdrawWallet
type UserLoyaltyRepositoryMockWithdrawWalletExpectation struct {
	mock    *UserLoyaltyRepositoryMock
	params  *UserLoyaltyRepositoryMockWithdrawWalletParams
	results *UserLoyaltyRepositoryMockWithdrawWalletResults
	Counter uint64
}

// UserLoyaltyRepositoryMockWithdrawWalletParams contains parameters of the UserLoyaltyRepository.WithdrawWallet
type UserLoyaltyRepositoryMockWithdrawWalletParams struct {
	ctx      context.Context
	userID   uuid.UUID
	withdraw *models.Withdraw
}

// UserLoyaltyRepositoryMockWithdrawWalletResults contains results of the UserLoyaltyRepository.WithdrawWallet
type UserLoyaltyRepositoryMockWithdrawWalletResults struct {
	err error
}

// Expect sets up expected params for UserLoyaltyRepository.WithdrawWallet
func (mmWithdrawWallet *mUserLoyaltyRepositoryMockWithdrawWallet) Expect(ctx context.Context, userID uuid.UUID, withdraw *models.Withdraw) *mUserLoyaltyRepositoryMockWithdrawWallet {
	if mmWithdrawWallet.mock.funcWithdrawWallet != nil {
		mmWithdrawWallet.mock.t.Fatalf("UserLoyaltyRepositoryMock.WithdrawWallet mock is already set by Set")
	}

	if mmWithdrawWallet.defaultExpectation == nil {
		mmWithdrawWallet.defaultExpectation = &UserLoyaltyRepositoryMockWithdrawWalletExpectation{}
	}

	mmWithdrawWallet.defaultExpectation.params = &UserLoyaltyRepositoryMockWithdrawWalletParams{ctx, userID, withdraw}
	for _, e := range mmWithdrawWallet.expectations {
		if minimock.Equal(e.params, mmWithdrawWallet.defaultExpectation.params) {
			mmWithdrawWallet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithdrawWallet.defaultExpectation.params)
		}
	}

	return mmWithdrawWallet
}

// Inspect accepts an inspector function that has same arguments as the UserLoyaltyRepository.WithdrawWallet
func (mmWithdrawWallet *mUserLoyaltyRepositoryMockWithdrawWallet) Inspect(f func(ctx context.Context, userID uuid.UUID, withdraw *models.Withdraw)) *mUserLoyaltyRepositoryMockWithdrawWallet {
	if mmWithdrawWallet.mock.inspectFuncWithdrawWallet != nil {
		mmWithdrawWallet.mock.t.Fatalf("Inspect function is already set for UserLoyaltyRepositoryMock.WithdrawWallet")
	}

	mmWithdrawWallet.mock.inspectFuncWithdrawWallet = f

	return mmWithdrawWallet
}

// Return sets up results that will be returned by UserLoyaltyRepository.WithdrawWallet
func (mmWithdrawWallet *mUserLoyaltyRepositoryMockWithdrawWallet) Return(err error) *UserLoyaltyRepositoryMock {
	if mmWithdrawWallet.mock.funcWithdrawWallet != nil {
		mmWithdrawWallet.mock.t.Fatalf("UserLoyaltyRepositoryMock.WithdrawWallet mock is already set by Set")
	}

	if mmWithdrawWallet.defaultExpectation == nil {
		mmWithdrawWallet.defaultExpectation = &UserLoyaltyRepositoryMockWithdrawWalletExpectation{mock: mmWithdrawWallet.mock}
	}
	mmWithdrawWallet.defaultExpectation.results = &UserLoyaltyRepositoryMockWithdrawWalletResults{err}
	return mmWithdrawWallet.mock
}

// Set uses given function f to mock the UserLoyaltyRepository.WithdrawWallet method
func (mmWithdrawWallet *mUserLoyaltyRepositoryMockWithdrawWallet) Set(f func(ctx context.Context, userID uuid.UUID, withdraw *models.Withdraw) (err error)) *UserLoyaltyRepositoryMock {
	if mmWithdrawWallet.defaultExpectation != nil {
		mmWithdrawWallet.mock.t.Fatalf("Default expectation is already set for the UserLoyaltyRepository.WithdrawWallet method")
	}

	if len(mmWithdrawWallet.expectations) > 0 {
		mmWithdrawWallet.mock.t.Fatalf("Some expectations are already set for the UserLoyaltyRepository.WithdrawWallet method")
	}

	mmWithdrawWallet.mock.funcWithdrawWallet = f
	return mmWithdrawWallet.mock
}

// When sets expectation for the UserLoyaltyRepository.WithdrawWallet which will trigger the result defined by the following
// Then helper
func (mmWithdrawWallet *mUserLoyaltyRepositoryMockWithdrawWallet) When(ctx context.Context, userID uuid.UUID, withdraw *models.Withdraw) *UserLoyaltyRepositoryMockWithdrawWalletExpectation {
	if mmWithdrawWallet.mock.funcWithdrawWallet != nil {
		mmWithdrawWallet.mock.t.Fatalf("UserLoyaltyRepositoryMock.WithdrawWallet mock is already set by Set")
	}

	expectation := &UserLoyaltyRepositoryMockWithdrawWalletExpectation{
		mock:   mmWithdrawWallet.mock,
		params: &UserLoyaltyRepositoryMockWithdrawWalletParams{ctx, userID, withdraw},
	}
	mmWithdrawWallet.expectations = append(mmWithdrawWallet.expectations, expectation)
	return expectation
}

// Then sets up UserLoyaltyRepository.WithdrawWallet return parameters for the expectation previously defined by the When method
func (e *UserLoyaltyRepositoryMockWithdrawWalletExpectation) Then(err error) *UserLoyaltyRepositoryMock {
	e.results = &UserLoyaltyRepositoryMockWithdrawWalletResults{err}
	return e.mock
}

// WithdrawWallet implements repositories.UserLoyaltyRepository
func (mmWithdrawWallet *UserLoyaltyRepositoryMock) WithdrawWallet(ctx context.Context, userID uuid.UUID, withdraw *models.Withdraw) (err error) {
	mm_atomic.AddUint64(&mmWithdrawWallet.beforeWithdrawWalletCounter, 1)
	defer mm_atomic.AddUint64(&mmWithdrawWallet.afterWithdrawWalletCounter, 1)

	if mmWithdrawWallet.inspectFuncWithdrawWallet != nil {
		mmWithdrawWallet.inspectFuncWithdrawWallet(ctx, userID, withdraw)
	}

	mm_params := UserLoyaltyRepositoryMockWithdrawWalletParams{ctx, userID, withdraw}

	// Record call args
	mmWithdrawWallet.WithdrawWalletMock.mutex.Lock()
	mmWithdrawWallet.WithdrawWalletMock.callArgs = append(mmWithdrawWallet.WithdrawWalletMock.callArgs, &mm_params)
	mmWithdrawWallet.WithdrawWalletMock.mutex.Unlock()

	for _, e := range mmWithdrawWallet.WithdrawWalletMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWithdrawWallet.WithdrawWalletMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithdrawWallet.WithdrawWalletMock.defaultExpectation.Counter, 1)
		mm_want := mmWithdrawWallet.WithdrawWalletMock.defaultExpectation.params
		mm_got := UserLoyaltyRepositoryMockWithdrawWalletParams{ctx, userID, withdraw}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithdrawWallet.t.Errorf("UserLoyaltyRepositoryMock.WithdrawWallet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithdrawWallet.WithdrawWalletMock.defaultExpectation.results
		if mm_results != nil {
			return (*mm_results).err
		}
		mmWithdrawWallet.t.Fatal("No results are set for the UserLoyaltyRepositoryMock.WithdrawWallet")
	}
	if mmWithdrawWallet.funcWithdrawWallet != nil {
		return mmWithdrawWallet.funcWithdrawWallet(ctx, userID, withdraw)
	}
	mmWithdrawWallet.t.Fatalf("Unexpected call to UserLoyaltyRepositoryMock.WithdrawWallet. %v %v %v", ctx, userID, withdraw)
	return
}

// WithdrawWalletAfterCounter returns a count of finished UserLoyaltyRepositoryMock.WithdrawWallet invocations
func (mmWithdrawWallet *UserLoyaltyRepositoryMock) WithdrawWalletAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithdrawWallet.afterWithdrawWalletCounter)
}

// WithdrawWalletBeforeCounter returns a count of UserLoyaltyRepositoryMock.WithdrawWallet invocations
func (mmWithdrawWallet *UserLoyaltyRepositoryMock) WithdrawWalletBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithdrawWallet.beforeWithdrawWalletCounter)
}

// Calls returns a list of arguments used in each call to UserLoyaltyRepositoryMock.WithdrawWallet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithdrawWallet *mUserLoyaltyRepositoryMockWithdrawWallet) Calls() []*UserLoyaltyRepositoryMockWithdrawWalletParams {
	mmWithdrawWallet.mutex.RLock()

	argCopy := make([]*UserLoyaltyRepositoryMockWithdrawWalletParams, len(mmWithdrawWallet.callArgs))
	copy(argCopy, mmWithdrawWallet.callArgs)

	mmWithdrawWallet.mutex.RUnlock()

	return argCopy
}

// MinimockWithdrawWalletDone returns true if the count of the WithdrawWallet invocations corresponds
// the number of defined expectations
func (m *UserLoyaltyRepositoryMock) MinimockWithdrawWalletDone() bool {
	for _, e := range m.WithdrawWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithdrawWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithdrawWalletCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithdrawWallet != nil && mm_atomic.LoadUint64(&m.afterWithdrawWalletCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithdrawWalletInspect logs each unmet expectation
func (m *UserLoyaltyRepositoryMock) MinimockWithdrawWalletInspect() {
	for _, e := range m.WithdrawWalletMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.WithdrawWallet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithdrawWalletMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithdrawWalletCounter) < 1 {
		if m.WithdrawWalletMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserLoyaltyRepositoryMock.WithdrawWallet")
		} else {
			m.t.Errorf("Expected call to UserLoyaltyRepositoryMock.WithdrawWallet with params: %#v", *m.WithdrawWalletMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithdrawWallet != nil && mm_atomic.LoadUint64(&m.afterWithdrawWalletCounter) < 1 {
		m.t.Error("Expected call to UserLoyaltyRepositoryMock.WithdrawWallet")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserLoyaltyRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckUserPasswordInspect()

			m.MinimockCreateOrderInspect()

			m.MinimockCreateUserInspect()

			m.MinimockGetWalletInspect()

			m.MinimockGetWithdrawalsInspect()

			m.MinimockListOrdersInspect()

			m.MinimockPingInspect()

			m.MinimockUpdateOrderAccuralInspect()

			m.MinimockWithdrawWalletInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserLoyaltyRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserLoyaltyRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckUserPasswordDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockGetWalletDone() &&
		m.MinimockGetWithdrawalsDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockPingDone() &&
		m.MinimockUpdateOrderAccuralDone() &&
		m.MinimockWithdrawWalletDone()
}
